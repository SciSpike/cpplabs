Introduction
------------
The following is are correcrection to the course material used at NASA the last week of October 2015. 

The corrections covers the corrections made the the slides during the course.

Becuase the material is assembled specifically for each course, the page references do not apply to any other courses.

Errata
------

Page|Heading|Location
----|:-------|:--------
14|Dynamic Objects with new and delete|First code segment, line 2


Before:

```C++
  Company * cptr; // uninitialized pointer
  cptr = 0; // initialized to 0 (same as NULL)
  cptr = new Company(“GM”); // constructor is finally called
```

Corrected to:

```C++
  Company * cptr; // uninitialized pointer
  cptr = nullptr; // nullptr was introduced in C++ 11, C++ 98 use 0
  cptr = new Company(“GM”); // constructor is finally called
```

Page|Heading|Location
----|:-------|:--------
483|Superclass Delegation…|Definition of the rectangle in code. Two errors. Inheritanche declaration and missing semicolon

Before:

```C++
class Rectangle {
public:
    void draw() {
       if (legendsShouldBePrinted) {
          printLegends()
       }
       //draw the rectangle
    }
};
```

After:

```C++
class Rectangle : public Shape {
public:
    void draw() {
       if (legendsShouldBePrinted) {
          printLegends();
       }
       //draw the rectangle
    }
};
```

Page|Heading|Location
----|:-------|:--------
589|C++ Rules for Method Arguments|The code segment was referring to super and sub in the comments. Also, the example has been expanded to include all variations from previous page.

Before:

```C++
 SpecialShapeHandler sub;
 ShapeHandler &super = sub;
 Rectangle rect;
 Shape &shape = rect;
 super.handleShape( r ); // calls Super::handleShape
 sub.handleShape( r ); // calls Super::handleShape
 super.handleShape( shape ); // error
 sub.handleShape( shape ); calls Sub::handleShape
```

After:
```C++
SpecialShapeHandler sub;
ShapeHandler &super = sub;
Rectangle rect;
Shape &shape = rect;
super.handleShape( rect ); 	// calls ShapeHandler::handleShape
sub.handleShape( rect ); 	// calls SpecialShapeHandler::handleShapesuper.handleShape( shape ); // error
sub.handleShape( shape ); 	// calls SpecialShapeHandler::handleShapesuper.doToShape( rect ); 	// calls ShapeHandler::doToShape
sub.doToShape( rect ); 		// calls SpecialShapeHandler::handleShapesuper.doToShape( shape ); 	// calls ShapeHandler::doToShape
sub.doToShape( shape ); 	// error
```

Page|Heading|Location
----|:-------|:--------
645|Examples|Multiple errors in the line 6 showing calling a function with implicit return type. The function called should be _f3_ and the comment should be mentioning variable _i3_.

Before:

```C++
auto f1 = [] () { cout << "hello world" << endl; };
f1();

auto f2 = [] (const string& msg) { cout << msg << endl; };
f2("hello world");

auto f3 = [] () { return 42; }; // implicit return type
auto i3 = f2(); // i1 is of type int

auto f4 = [] () -> int { return 42; ); // explicit return type
auto i4 = f4();
```

After:

```C++

auto f1 = [] () { cout << "hello world" << endl; };
f1();

auto f2 = [] (const string& msg) { cout << msg << endl; };
f2("hello world");

auto f3 = [] () { return 42; }; // implicit return type
auto i3 = f3(); // i3 is of type int

auto f4 = [] () -> int { return 42; ); // explicit return type
auto i4 = f4();
```

Page|Heading|Location
----|:-------|:--------
647|Example of Capture|The slide is correct, however the example can be made more interesting by having the main invoke the closure. The slide was changed in the class to make it more interesting.

Before:

```C++
class Foo {
public:
    Foo () : myVar( 42 ) {}
    void func () {
        // implicit access to myVar from the capture of this
        [this] () { cout << myVar; } ();
    }
private:
        int myVar;
};

int main() {
    Foo f;
    f.func();
}
```

After:
```
class Foo {
public:
    Foo () : myVar( 42 ) {}
    std::function<void()> func () {
        // implicit access to myVar from the capture of this
        int x = 42;
        return [this] () { cout << myVar << x; } ;
    }
private:
        int myVar;
};

int main() {
    Foo f;
    std::function<void()> function = f.func();
    fuction(); // prints and accesses private variable inside Foo
}
```